function [alpha, beta, k, pi, residual] = solve_reg_dual(mu1, mu2, c, gamma, epsilon, TOL)
%SOLVE_REG_DUAL Computes a solution to the regularized dual problem of the
%regularized Kantorovich (Hitchcock) problem
%
% Inputs:
%   - mu1:     Source marginal (vector)
%   - mu2:     Target marginal (vector)
%   - c:       Cost matrix (matrix)
%   - gamma:   Regularization parameter for Kantorovich problem (positive scalar)
%   - epsilon: Regularization parameter for dual problem (positive scalar)
%
% Outputs:
%   - pi:       Solution (matrix)
%   - alpha:    First dual variable (vector)
%   - beta:     Second dual variable (vector)
%   - k:        Number of iterations taken (positive integer)
%   - residual: Error generated by the computed solution pi, i.e., maximum
%               of the deviation of the first-order optimality system's
%               left-hand and the right-hand side (nonnegative scalar)

% Fetch dimensions of the problem and construct auxiliary vectors
n1 = numel(mu1); n2 = numel(mu2);
onesm = ones(n1, 1); onesn = ones(n2, 1);

% Choose either the semismooth Newton method from the Lorenz-Manns-Meyer
% paper (0) or Matlab's nonlinear equation solver (1)
matlab_solver = 0;
if matlab_solver
    % Construct the function that describes the system of nonlinear
    % equations
    F = @(ab) [ (max(0, ab(1:n1) + ab(n1+1:n1+n2)' - c)) * onesn;
        (max(0, ab(1:n1) + ab(n1+1:n1+n2)' - c))' * onesm ] ...
        + gamma * epsilon * ab - gamma * [mu1; mu2];

    % Call Matlab's build-in nonlinear equation solver
    options = optimoptions("fsolve", "FunctionTolerance", eps, ...
        "OptimalityTolerance", eps, "Display", "none");
    ab0 = zeros(n1+n2, 1); % Start with 0
    [alphabeta, Fval, exitflag, output] = fsolve(F, ab0, options);

    % Assemble solution
    alpha = alphabeta(1:n1);
    beta = alphabeta(n1+1:n1+n2);
    pi = 1/gamma * max(0, alpha + beta' - c);

    % Iteration data
    residual = max(abs(Fval));
    k = output.iterations;
else
    % Choose parameters for the semismooth Newton method
    theta = 0.01;
    kappa = 0.5;
    maxiter = 2*n1*n2;

    % Initialization
    alpha = mu1;
    beta = mu2;
    k = 0;
    done = 0;

    % Iteration
    while (~done) && (k <= maxiter)
        % Construct matrices P, sigma, and pi
        if k == 0
            P = alpha + beta' - c;
            sigma = max(sign(P), 0);
            pi = 1/gamma * max(P, 0);
        end

        % Construct newton derivative G and right-hand side F
        G = [diag(sigma * onesn), sigma;
            sigma',               diag(sigma' * onesm)];
        F = gamma * [pi * onesn - mu1; pi' * onesm - mu2];

        % Construct regularized newton derivative and regularized
        % right-hand side
        G_epsilon = G + gamma * epsilon * eye(n1+n2);
        F_epsilon = F + gamma * epsilon * [alpha; beta];

        % Compute solution of system G_epsilon * d = - F_epsilon
        d = G_epsilon \ - F_epsilon;

        % Check that d solves the system with sufficient precision
        if sum((G_epsilon * d + F_epsilon).^2, "all") > TOL
            error('d solves the system G_epsilon * d = F_epsilon not sufficiently well!')
        end

        % Split d into separate directions
        dalpha = d(1:n1); dbeta = d(n1+1:n1+n2);

        % Compute the directional derivative
        direcderiv = sum(pi .* (dalpha + dbeta'), "all") ...
            + epsilon * (dalpha' * alpha + dbeta' * beta) ...
            - (dalpha' * mu1 + dbeta' * mu2);

        % Line search
        kls = 0;
        t = 1;
        phiref = phi_epsilon(alpha, beta, c, mu1, mu2, gamma, epsilon);
        while (phi_epsilon(alpha + t * dalpha, beta + t * dbeta, c, ...
                mu1, mu2, gamma, epsilon) > phiref + t * ...
                theta * direcderiv) && (kls <= maxiter)
            t = kappa * t;
            kls = kls + 1;
        end

        % Update step
        k = k + 1;
        alpha = alpha + t * dalpha;
        beta = beta + t * dbeta;
        P = alpha + beta' - c;
        sigma = max(sign(P), 0);
        pi = 1/gamma * max(P, 0);

        % (Regularized) termination criterion
        residual = max( max(abs(pi * onesn + epsilon * alpha - mu1)), ...
            max(abs(pi' * onesm + epsilon * beta - mu2)) );
        if residual <= TOL
            done = 1;
        end
    end
end
end

% Auxiliary function for line search
function val = phi_epsilon(alpha, beta, c, mu, nu, gamma, epsilon)
gammapi = max(alpha + beta' - c, 0);
val = 1/(2 * gamma) * sum(gammapi .* gammapi, "all") ...
    - (alpha' * mu + beta' * nu) ...
    + epsilon/2 * (alpha' * alpha + beta' * beta);
end